{"version":3,"file":"static/js/357.761bb681.chunk.js","mappings":"qNAEe,SAASA,IAEtB,OAAwBC,EAAAA,EAAAA,WAAS,kBAAM,IAAIC,IAAV,IAAjC,eAAOC,EAAP,KAAaC,EAAb,KAEMC,GAAaC,EAAAA,EAAAA,QAAO,MAC1BC,QAAQC,IAAIH,IAEZI,EAAAA,EAAAA,YAAU,WAKR,OAJAJ,EAAWK,QAAUC,aAAY,WAC/BJ,QAAQC,IAAI,mHAAgCN,KAAKU,OACjDR,EAAQ,IAAIF,KACb,GAAE,KACI,WACLK,QAAQC,IAAI,uPACZK,GACD,CACF,GAAE,IAEH,IAAMA,EAAO,WACXC,cAAcT,EAAWK,QAC1B,EAED,OACE,4BACE,mCACA,mBAAQK,KAAK,SAASC,QAAS,kBAAMZ,EAAQ,IAAIF,KAAlB,EAA/B,+DAGA,uGAAmBC,EAAKc,yBACxB,mBAAQF,KAAK,SAASC,QAASH,EAA/B,4EAKL,C","sources":["components/HooksExamples/Clock.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\n\nexport default function Clock() {\n  // чтоб при изменении времени не было рендера делфется ленивая инициализация. Если начальное состояние зависит от выражения - надо делать ленивую загрузку, передать функцию, которая возвращает значение\n  const [time, setTime] = useState(() => new Date());\n  // current свойство useRef , в которое сохраняется значение при первом рендере\n  const intervalId = useRef(null);\n  console.log(intervalId);\n\n  useEffect(() => {\n    intervalId.current = setInterval(() => {\n      console.log('Это интервал каждые 5000ms ' + Date.now());\n      setTime(new Date());\n    }, 5000);\n    return () => {\n      console.log('Это функция очистки перед следующим вызовом useEffect');\n      stop();\n    };\n  }, []);\n\n  const stop = () => {\n    clearInterval(intervalId.current);\n  };\n\n  return (\n    <div>\n      <h2>Clock</h2>\n      <button type=\"button\" onClick={() => setTime(new Date())}>\n        Обновить\n      </button>\n      <p>Текущее время: {time.toLocaleTimeString()}</p>\n      <button type=\"button\" onClick={stop}>\n        Остановить\n      </button>\n    </div>\n  );\n}\n\n// class OldClock extends Component {\n//   state = {\n//     time: new Date(),\n//   };\n\n//   intervalId = null;\n\n//   componentDidMount() {\n//     this.intervalId = setInterval(() => {\n//       console.log('Это интервал каждые 1000ms ' + Date.now());\n//       this.setState({ time: new Date() });\n//     }, 1000);\n//   }\n\n//   componentWillUnmount() {\n//     console.log('Эот метод вызывается перед размонтированием компонента');\n//     this.stop();\n//   }\n\n//   stop = () => {\n//     clearInterval(this.intervalId);\n//   };\n\n//   render() {\n//     return (\n//       <div className={styles.container}>\n//         <p className={styles.clockface}>\n//           Текущее время: {this.state.time.toLocaleTimeString()}\n//         </p>\n//         <button type=\"button\" onClick={this.stop}>\n//           Остановить\n//         </button>\n//       </div>\n//     );\n//   }\n// }\n"],"names":["Clock","useState","Date","time","setTime","intervalId","useRef","console","log","useEffect","current","setInterval","now","stop","clearInterval","type","onClick","toLocaleTimeString"],"sourceRoot":""}